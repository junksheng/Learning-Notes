---
layout: posts
title: Leetcode 第189场周赛
date: 2020-05-17 19:53:21
author: JunkSheng
img: /images/git.jpg
top: false
cover: false
coverImg: /images/git.jpg
toc: false
mathjax: false
summary: AC两道, 在既定时间做作业的学生人数, 重新排列句子中的单词, 收藏清单, 圆形靶内的最大飞镖数量. 
categories: Algorithm
tags:
  - Algorithm
  - Leetcode
  - Leetcode周赛
---

### [5412. 在既定时间做作业的学生人数](https://leetcode-cn.com/problems/number-of-students-doing-homework-at-a-given-time/)

给你两个整数数组 `startTime`（开始时间）和 `endTime`（结束时间），并指定一个整数 `queryTime` 作为查询时间。

已知，第 i 名学生在 `startTime[i]` 时开始写作业并于 `endTime[i]` 时完成作业。

请返回在查询时间 `queryTime` 时正在做作业的学生人数。形式上，返回能够使 `queryTime `处于区间 `[startTime[i], endTime[i]]`（含）的学生人数。

 

示例 1：

```
输入：startTime = [1,2,3], endTime = [3,2,7], queryTime = 4
输出：1
解释：一共有 3 名学生。
第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。
第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。
第二名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。
```

示例 2：

```
输入：startTime = [4], endTime = [4], queryTime = 4
输出：1
解释：在查询时间只有一名学生在做作业。
```

示例 3：

```
输入：startTime = [4], endTime = [4], queryTime = 5
输出：0
```

示例 4：

```
输入：startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7
输出：0
```

示例 5：

```
输入：startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5
输出：5
```

提示：

+ `startTime.length` == `endTime.length`
+ `1 <= startTime.length <= 100`
+ `1 <= startTime[i] <= endTime[i] <= 1000`
+ `1 <= queryTime <= 1000`



#### 思路

开胃菜, 直接遍历即可, 如果`queryTime` >= `startTime` && `queryTime` <= `endTime`, `result++`



#### 状态: AC

#### 提交代码

```java
class Solution {
    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
        int count = 0;
        for(int i=0;i < startTime.length; i++) {
            if(startTime[i] > queryTime) 
            else {
                if(endTime[i] >= queryTime)
                    count++;
            }
        }
        return count;
    }
}
```





### [5413. 重新排列句子中的单词](https://leetcode-cn.com/problems/rearrange-words-in-a-sentence/)

「句子」是一个用空格分隔单词的字符串。给你一个满足下述格式的句子 text :

+ 句子的首字母大写

+ text 中的每个单词都用单个空格分隔。

请你重新排列 text 中的单词，使所有单词按其长度的升序排列。如果两个单词的长度相同，则保留其在原句子中的相对顺序。

请同样按上述格式返回新的句子。



**示例 1：**

```
输入：text = "Leetcode is cool"
输出："Is cool leetcode"
解释：句子中共有 3 个单词，长度为 8 的 "Leetcode" ，长度为 2 的 "is" 以及长度为 4 的 "cool" 。
输出需要按单词的长度升序排列，新句子中的第一个单词首字母需要大写。
```

**示例 2：**

```
输入：text = "Keep calm and code on"
输出："On and keep calm code"
解释：输出的排序情况如下：
"On" 2 个字母。
"and" 3 个字母。
"keep" 4 个字母，因为存在长度相同的其他单词，所以它们之间需要保留在原句子中的相对顺序。
"calm" 4 个字母。
"code" 4 个字母。
```



**示例 3：**

```
输入：text = "To be or not to be"
输出："To be or to be not"
```



**提示：**

- `text` 以大写字母开头，然后包含若干小写字母以及单词间的单个空格。
- `1 <= text.length <= 10^5`



#### 思路: 



#### 状态: AC



#### 提交代码: 

```java
class Solution {
    public String arrangeWords(String text) {
        //先划分为数组, 按照空格划分
        String[] textArray = text.split(" ");
        
        //重写compare接口, 对字符数组排序. 
        Comparator cmp = new CMP();
        Arrays.sort(textArray, cmp);
        System.out.println(Arrays.toString(textArray));
        
        StringBuffer res = new StringBuffer("");
        for(String s: textArray) {
            res.append(s);
            res.append(" ");
        }
        
        res.deleteCharAt(res.length()-1);
        
        res.replace(0,res.length()-1,
               	res.substring(0,res.length()-1).toLowerCase());
        res.replace(0,1,res.substring(0,1).toUpperCase());
        
        return res.toString();
    }
}

class CMP implements Comparator<String> {
    public int compare(String a, String b) {
        if(a.length() == b.length())
            return 0;
        else if(a.length() > b.length())
            return 1;
        else
            return -1;

    }
}
```



#### 优化代码: 





